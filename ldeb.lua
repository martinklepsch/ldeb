#!/usr/bin/env lua
-- ldeb generating Debian archives from Lua scripts
local ml = require 'ml'
local usage = [[
ldeb command [options] parameters
    -t test only
     linstall  (Lua modules)  install Debian Lua packages
     show (Lua modules|all) show installed Debian Lua packages     
        'show all' gives you a list of available modules
     set  (email|name|editor|homepage) value
     guess  try to get name and email from Git if available and set     
     pack [options] scriptname
        Build a .deb file
        -L Lua version (default 5.1, otherwise 5.2)
        -o package name
           (otherwise, use basename of script)
        -d, --depends  external dependencies, as Lua modules
            (otherwise, read from soar.out)
        -m, --description description of package
           (otherwise, ask user to edit this)
        -v, --version package version (default 1.0)
        -u, --url project homepage
     install 
        Install the .deb generated by the last pack (needs sudo)
]]

local quit, execute, exec, shell, read_config, write_config, guess_email, test, edit, mustbe
local lua52 = _VERSION:match '5%.2$'

local packages = {
bit= "bitop",  -- -- fast bit manipulation library for the Lua language v
cgilua="cgi",  -- -- CGI library for the Lua language version 5.1        
sapi="cgi",  -- -- CGI library for the Lua language version 5.1  
cjson="cjson",
copas="copas",  -- -- Copas is a dispatcher of concurrent TCP/IP requests 
cosmo="cosmo",  -- -- A template library for the Lua langua version 5.1   
coxpcall="coxpcall",  -- -- Protected function calls across coroutines for Lua 5
discount="discount", -- -- Fast Markdown processor
curl="curl",  -- -- libcURL bindings for the Lua language version 5.1   
luaevent="event",  -- -- asynchronous event notification library for Lua vers
lxp="expat",  -- -- libexpat bindings for the Lua language version 5.1  
["lxp.lom"]="expat",  -- -- libexpat bindings for the Lua language version 5.1
lfs="filesystem",  -- -- luafilesystem library for the Lua language version 5
iconv="iconv",  -- -- iconv bindings for the Lua programming language     
json="json",  -- -- JSON decoder/encoder for Lua                        
leg="leg",  -- -- Lua 5.1 grammar, with parsing and manipulation facil
lpty="lpty", -- -- pseudo-terminal support
p="logging",  -- -- lualogging library for the Lua language version 5.1 
pl="penlight", -- -- General purpose Lua libraries
lpeg="lpeg",  -- -- LPeg library for the Lua language version 5.1       
markdown="markdown",  -- -- A pure lua5.1 implementation of the Markdown text-to
md5="md5",  -- -- MD5 library for the Lua language version 5.1        
orbit="orbit",  -- -- MVC web framework for Lua                           
posix="posix",  -- -- posix library for the Lua language version 5.1      
re="pcre",  -- -- Perl regular expressions library for the Lua languag
rings="rings",  -- -- Lua state creation and control library for the Lua l
ssl="sec",  -- -- SSL socket library for the Lua language version 5.1 
soap="soap",  -- -- SOAP library for the Lua language version 5.1       
socket="socket",  -- -- TCP/UDP socket library for Lua 5.1   
ltn12="socket",  -- -- TCP/UDP socket library for Lua 5.1    
mime="socket",  -- -- TCP/UDP socket library for Lua 5.1  
zip="zip",  -- -- zip library for the Lua language version 5.1        
['luasql.sqlite3'] = "sql-sqlite3" ,  -- luasql library for the Lua language version 5.1
['luasql.postgres'] = " sql-postgres",  -- luasql library for the Lua language version 5.1
['luasql.mysql'] = "sql-mysql", -- luasql library for the Lua language version 5.1
zlib="zlib",
}


local lua = "lua5.1"
if lua52 then lua = "lua5.2" end

----- not sure how to handle these chaps ----
--~ p   liblua5.1-wsapi-fcgi-1                    -- Web server API fastcgi backend                      
--~ p   liblua5.1-wsapi1                          -- Web server API abstraction layer for the Lua languag
--~ p   liblua5.1-xmlrpc0                         -- xmlrpc library for the Lua language version 5.1     

local function resolve_dependencies(mods,pkgs)
	for i,mod in ipairs(mods) do
	    local package = packages[mod]
	    if not package then
            quit("cannot find "..mod..' - not a known Lua module')
	    end
	    pkgs[i] = lua..'-'..package
	end
end

function main()
    if #arg == 0 then quit("no parameters",true) end
    -- these shenanigans are necessary to get the original user's
    -- configuration file when run under sudo
    local user = shell 'logname'
    local home
    if not user then
        home = os.getenv 'HOME'
    else
        home = '/home/'..user
    end
    local CONFIG = home..'/.ldebrc' 
    local config = read_config(CONFIG)    
   
    --- parse commad line args
    local scriptname, binmods, name, description, email, extra, homepage
    local version = "1.0"
    local i = 2
    local function nextarg()
        i = i + 1
        return arg[i]
    end
    
    local cmd = arg[1]

    while i <= #arg do
        local a = arg[i]
        if a == '-o' then
            name = nextarg()
        elseif a == '-d' or a == '--depends' then
            binmods = ml.split(nextarg())
        elseif a == '-m' or a == '--description' then
            description = nextarg()
        elseif a == '-v' or a == '--version' then
            version = nextarg()
        elseif a == '-u' or a == '--url' then
            homepage = nextarg()
        elseif a == '-t' then
            test = true
        elseif a == '-L' then 
            local a = nextarg()
            if a == '5.2' then
                lua = 'lua5.2'
            elseif a ~= '5.1' then
                quit("unknown Lua version - either 5.1 or 5.2",false)
            end
        else
            scriptname = a	
            break
        end
        i = i + 1
    end
    extra = ml.sub(arg,i)
    
    if cmd == 'help' then
        quit("help",true)
    end
    
    if cmd == "packages" then
        if not config.packages then return end
        for name,p in pairs(config.packages) do
            print(name,p.description,p.version)
        end
        return
    end
    
    if cmd == 'install' then
        if not config.lastdeb then
            quit("no packed deb available; do a pack first")
        end
        exec('dpkg -i '..config.lastdeb)
        return
    end    
    
    if cmd == 'linstall'  or cmd == 'show' then
        if cmd == 'show' and scriptname == 'all' then
            for k,p in pairs(packages) do
                print(k,lua..'-'..p)
            end
            return
        end
        resolve_dependencies(extra,extra)
        extra = table.concat(extra,' ')
        extra = extra:gsub('5%.%d','')
        if cmd == 'linstall' then
            exec('apt-get install '..extra)
        else
            exec('apt-cache show '..extra)
        end
        return
    end

    if cmd == 'guess' or cmd == 'set' then
        if cmd == 'guess' then
            guess_email(config)
        else
            config[scriptname] = mustbe(nextarg(),"please specify value")
        end
        write_config(CONFIG,config)
        return
    end

    if cmd ~= 'pack' then quit("unknown command") end  
    
    if not scriptname then quit("must provide script name",true) end
    
    for _,s in ipairs(extra) do
        if not ml.exists(s) then
            quit(s.." does not exist")
        end
    end

    if not name then -- no explicit package name; deduce from first script
        _, name = ml.splitpath(scriptname)
    end

    if not email then
        if config.email or config.name then
            email = (config.name or '')..' <'..config.email..'>'
        else
            quit "please set name and email"
        end
    end
    
    homepage = homepage or config.homepage
    
    local wants_to_edit
    if description == 'edit' then
        wants_to_edit = true
        description = nil
    end
    if not description  then -- let user edit the description
        local package = config.packages and config.packages[name]
        if package then
            description = package.description
        end
        if not description or wants_to_edit then
            local tmpfile = os.tmpname()
            local f = io.open(tmpfile,'w')
            if description then            
                f:write(description,'\n')
            end
            f:write '\n###### DESCRIPTION ######\n'
            f:close()
            edit(config,tmpfile)
            description = ml.readfile(tmpfile):gsub ('[%s\n]*###.+$','')
        end
        if description == '' then
            quit("you really do need to set the description")
        end
    end

    -- see what Debian packages correspond to these Lua modules
    if binmods then
        resolve_dependencies(binmods,binmods)
    else
        local soar = read_config ('soar.out')
        binmods = {}
        if not soar then
            print 'WARNING --- no extra dependencies specified, and no soar.out file --'            
        else
            local append = table.insert
            for k,v in pairs(soar) do
                if type(v) ~= 'string' then
                    append(binmods,k)
                end
            end
            if #binmods > 0 then
                resolve_dependencies(binmods,binmods)
            end
        end
    end
     --- ensure that the lua executable is explicitly depended on!
    table.insert(binmods,1,lua)

    local dir = name..version
    local bindir = dir..'/usr/local/bin'

    exec ('mkdir -p '..dir..'/DEBIAN')
    exec('mkdir -p '..bindir)
    local total_size = 0
    -- and copy our scripts to the binary dir
    for _,s in ipairs(extra) do
        exec('cp -p '..s..' '..bindir)
        local sz = tonumber(shell('ls -s '..s):match '%d+')
        total_size = total_size + sz
    end

    local f = test and io.stdout or io.open(dir..'/DEBIAN/control','w')
    f:write('Package: ',name,'\n')
    f:write('Version: ',version,'\n')
    f:write('Architecture: all\n')
    f:write('Installed-Size: ',total_size,'\n')
    if email then
        f:write('Maintainer: ',email,'\n')
    end
    if homepage then
        f:write('Homepage: '..homepage,'\n')
    end
    if binmods then
        f:write('Depends: ',table.concat(binmods,', '),'\n')
    end
    if description then
        f:write('Description: ',description,'\n')
    end
    if not test then f:close() end

    exec('dpkg-deb --build '..dir)
    
    if not config.packages then
        config.packages = {}
    end
    config.packages[name] = {
        description = description,
        version = version
    }
    config.lastdeb = dir..'.deb'
    
    write_config(CONFIG,config)

end

function guess_email (config)
    config.email = nil
    config.name = nil
    if execute 'git --version' then
        config.email = shell 'git config --global --get user.email'
        config.name = shell 'git config --global --get user.name'
        if not config.email or not config.name then
            quit "git: either name or email not set"
        end
    else
        quit "cannot guess name and email from git"
    end
end

function execute (cmd)
    local res = os.execute(cmd)
    return lua52 and res or (res==0)
end

function edit (config,file)
    local editor = config.editor or os.getenv 'VISUAL' or os.getenv 'EDITOR' or 'vi'
    return execute(editor..' '..file)
end

function quit(msg,use)
    io.stderr:write(msg,'\n')
    if use then io.stderr:write(usage) end
    os.exit(1)
end

function mustbe (val,msg)
    if not val then quit(msg) end
    return val
end

function exec (cmd,args)
    if type(args) == 'table' then
        cmd = ml.expand(cmd,args)
    end
    print(cmd)
    if test then return end
    if not execute (cmd) then
        io.stderr:write '+++borked..\n'
        os.exit(0)
    end
end

function shell (cmd)
    local f = io.popen(cmd,'r')
    local line = f:read()
    f:close()
    return line
end

function read_config(cfile)
    if ml.exists(cfile) then
        local cstr = ml.readfile(cfile)
        local chunk  = loadstring("return "..cstr)
        return chunk()
    else
        return {}
    end
end

function write_config(cfile,config)
    local f = io.open(cfile,'w')
    f:write(ml.tstring(config),'\n')
    f:close()
end

main()
